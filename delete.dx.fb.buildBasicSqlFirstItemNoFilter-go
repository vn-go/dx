// package dx

// import (
// 	"fmt"
// 	"reflect"
// 	"strings"
// 	"sync"

// 	"github.com/vn-go/dx/dialect/factory"
// 	"github.com/vn-go/dx/expr"
// 	"github.com/vn-go/dx/internal"
// 	"github.com/vn-go/dx/model"
// )

// var cacheBuildBasicSqlFirstItemNoFilter sync.Map

// func buildBasicSqlFirstItemNoFilter(typ reflect.Type, db *DB) (string, string, [][]int, error) {
// 	key := db.DriverName + "://" + db.DbName + "/" + typ.String()
// 	actual, _ := cacheBuildBasicSqlFirstItemNoFilter.LoadOrStore(key, &initBuildBasicSqlFirstItemNoFilter{})
// 	initBuild := actual.(*initBuildBasicSqlFirstItemNoFilter)
// 	initBuild.once.Do(func() {
// 		sql, filter, keyFieldIndex, err := buildBasicSqlFirstItemNoFilterNoCache(typ, db)
// 		initBuild.sqlSelect = sql
// 		initBuild.filter = filter
// 		initBuild.err = err
// 		initBuild.keyFieldIndex = keyFieldIndex
// 	})
// 	return initBuild.sqlSelect, initBuild.filter, initBuild.keyFieldIndex, initBuild.err
// }
// func (db *DB) buildBasicSqlFirstItemNoFilter(typ reflect.Type) (string, string, [][]int, error) {
// 	key := reflect.TypeOf(db).Elem().String() + "://" + db.DriverName + "://" + db.DbName + "/" + typ.String() + "@buildBasicSqlFirstItemNoFilter"

// 	//key := typ.String() + "://" + db.DbName + "://" + db.DriverName
// 	ret, err := internal.OnceCall(key, func() (*struct {
// 		sql           string
// 		sqlCompiler   string
// 		keyFieldIndex [][]int
// 	}, error) {

// 		dialect := factory.DialectFactory.Create(db.DriverName)

// 		repoType, err := model.ModelRegister.GetModelByType(typ)
// 		if err != nil {
// 			return nil, err
// 		}
// 		tableName := repoType.Entity.TableName
// 		compiler, err := expr.CompileJoin(tableName, db.DB)
// 		if err != nil {
// 			return nil, err
// 		}
// 		tableName = compiler.Content
// 		columns := repoType.Entity.Cols

// 		fieldsSelect := make([]string, len(columns))
// 		filterFields := []string{}
// 		keyFieldIndex := [][]int{}
// 		for i, col := range columns {
// 			if col.PKName != "" {
// 				filterFields = append(filterFields, repoType.Entity.TableName+"."+col.Name+" =?")
// 				keyFieldIndex = append(keyFieldIndex, col.IndexOfField)
// 			}
// 			fieldsSelect[i] = repoType.Entity.TableName + "." + col.Field.Name + " AS " + col.Field.Name
// 		}
// 		filter := strings.Join(filterFields, " AND ")
// 		compiler.Context.Purpose = expr.BUILD_SELECT //build_purpose_select
// 		err = compiler.BuildSelectField(strings.Join(fieldsSelect, ", "))
// 		if err != nil {
// 			return nil, err
// 		}
// 		strField := compiler.Content

// 		sql := fmt.Sprintf("SELECT %s FROM %s", strField, tableName)
// 		if filter != "" {
// 			compiler.Context.Purpose = expr.BUILD_WHERE //build_purpose_where
// 			err = compiler.BuildWhere(filter)
// 			if err != nil {
// 				return nil, err
// 			}

// 		}
// 		sql = dialect.MakeSelectTop(sql, 1)
// 		return &struct {
// 			sql           string
// 			sqlCompiler   string
// 			keyFieldIndex [][]int
// 		}{
// 			sql:           sql,
// 			sqlCompiler:   compiler.Content,
// 			keyFieldIndex: keyFieldIndex,
// 		}, nil
// 		//return sql, compiler.Content, keyFieldIndex, nil
// 	})
// 	if err != nil {
// 		return "", "", nil, err
// 	}
// 	return ret.sql, ret.sqlCompiler, ret.keyFieldIndex, nil
// }